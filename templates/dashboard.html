<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Vision Assistant - Web Dashboard</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.2/socket.io.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            overflow-x: hidden;
        }

        .container {
            display: flex;
            justify-content: center;
            padding: 20px;
            min-height: 100vh;
        }

        .main-panel {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            max-width: 1400px;
            width: 100%;
        }



        .panel-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 20px;
            font-size: 1.4em;
            font-weight: bold;
        }

        .camera-container {
            position: relative;
            border-radius: 15px;
            overflow: hidden;
            background: #000;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        #camera-feed {
            width: 100%;
            height: auto;
            display: block;
        }

        .status-overlay {
            position: absolute;
            top: 15px;
            left: 15px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 15px;
            border-radius: 10px;
            backdrop-filter: blur(5px);
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 5px;
        }

        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #00ff41;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }







        .stats-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin-top: 20px;
        }
        
        @media (max-width: 768px) {
            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .stat-value {
            font-size: 1.8em;
            font-weight: bold;
            color: #00ff41;
        }

        .stat-label {
            font-size: 0.9em;
            color: #ccc;
            margin-top: 5px;
        }

        .scrollbar {
            scrollbar-width: thin;
            scrollbar-color: rgba(255, 255, 255, 0.3) transparent;
        }

        .scrollbar::-webkit-scrollbar {
            width: 6px;
        }

        .scrollbar::-webkit-scrollbar-track {
            background: transparent;
        }

        .scrollbar::-webkit-scrollbar-thumb {
            background-color: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none;
        }

        /* Terminal Output Styles */
        .terminal-container {
            background: rgba(0, 0, 0, 0.8);
            border-radius: 15px;
            padding: 15px;
            margin-top: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            max-height: 400px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .terminal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }

        .terminal-title {
            font-size: 1.1em;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .terminal-controls {
            display: flex;
            gap: 10px;
        }

        .terminal-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 5px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.3s;
        }

        .terminal-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .terminal-output {
            background: #000;
            color: #00ff41;
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
            padding: 10px;
            border-radius: 8px;
            height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
            line-height: 1.4;
        }

        .terminal-output::-webkit-scrollbar {
            width: 8px;
        }

        .terminal-output::-webkit-scrollbar-track {
            background: #1a1a1a;
        }

        .terminal-output::-webkit-scrollbar-thumb {
            background: #00ff41;
            border-radius: 4px;
        }

        .terminal-line {
            margin: 2px 0;
            opacity: 0;
            animation: fadeIn 0.3s forwards;
        }

        @keyframes fadeIn {
            to { opacity: 1; }
        }

        .terminal-line.error {
            color: #ff4444;
        }

        .terminal-line.warning {
            color: #ffaa00;
        }

        .terminal-line.info {
            color: #00aaff;
        }

        /* Voice Command Buttons */
        .command-btn {
            background: linear-gradient(135deg, rgba(0, 255, 65, 0.2), rgba(0, 200, 50, 0.2));
            border: 1px solid rgba(0, 255, 65, 0.4);
            color: white;
            padding: 12px 15px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.3s;
            text-align: center;
            font-weight: 500;
            position: relative;
            overflow: hidden;
        }

        .command-btn:hover {
            background: linear-gradient(135deg, rgba(0, 255, 65, 0.3), rgba(0, 200, 50, 0.3));
            border-color: rgba(0, 255, 65, 0.6);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 255, 65, 0.3);
        }

        .command-btn:active {
            transform: translateY(0);
        }

        .command-btn.executing {
            background: linear-gradient(135deg, rgba(255, 170, 0, 0.3), rgba(255, 140, 0, 0.3));
            border-color: rgba(255, 170, 0, 0.6);
            pointer-events: none;
        }

        .command-btn.executing::after {
            content: '‚è≥';
            position: absolute;
            right: 10px;
            animation: spin 1s linear infinite;
        }

        .command-btn-title {
            font-weight: bold;
            display: block;
            margin-bottom: 3px;
            text-transform: capitalize;
        }

        .command-btn-desc {
            font-size: 0.75em;
            opacity: 0.8;
            display: block;
        }

    </style>
</head>
<body>
    <div class="container">
        <!-- Main Panel - Camera Feed -->
        <div class="main-panel">
            <div class="panel-header">
                üìπ AI Vision Assistant
                <div class="loading" id="connection-indicator"></div>
            </div>
            
            <div class="camera-container">
                <img id="camera-feed" src="/video_feed" alt="Camera Feed" />
                <div class="status-overlay">
                    <div class="status-indicator">
                        <div class="status-dot"></div>
                        <span id="status-text">Initializing...</span>
                    </div>
                    <div id="fps-display">FPS: --</div>
                    <div id="objects-count">Objects: --</div>
                </div>
            </div>


            <!-- Voice Commands Section -->
            <div class="terminal-container" style="margin-top: 20px;">
                <div class="terminal-header">
                    <div class="terminal-title">
                        üé§ Voice Commands
                        <span style="font-size: 0.7em; color: #888;">(Click to execute)</span>
                    </div>
                </div>
                <div style="padding: 15px; display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 10px; max-height: 300px; overflow-y: auto;" class="scrollbar" id="voice-commands-grid">
                    <div style="text-align: center; padding: 20px; color: #888;">Loading commands...</div>
                </div>
            </div>

            <!-- Terminal Output Section -->
            <div class="terminal-container">
                <div class="terminal-header">
                    <div class="terminal-title">
                        üíª Terminal Output
                        <span style="font-size: 0.7em; color: #888;">(Live)</span>
                    </div>
                    <div class="terminal-controls">
                        <button class="terminal-btn" id="toggle-scroll-btn" onclick="toggleAutoScroll()">
                            üîí Auto-scroll: ON
                        </button>
                        <button class="terminal-btn" onclick="clearTerminal()">
                            üóëÔ∏è Clear
                        </button>
                    </div>
                </div>
                <div class="terminal-output scrollbar" id="terminal-output">
                    <div class="terminal-line">Waiting for terminal output...</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Socket.IO connection with increased timeout
        const socket = io({
            transports: ['websocket', 'polling'],
            timeout: 60000,
            reconnection: true,
            reconnectionDelay: 1000,
            reconnectionDelayMax: 5000,
            reconnectionAttempts: Infinity
        });
        let sessionStartTime = Date.now();
        let commandCount = 0;
        let autoScroll = true;
        let terminalLineCount = 0;
        const MAX_TERMINAL_LINES = 500;

        // Connection status
        socket.on('connect', function() {
            console.log('Connected to server');
            document.getElementById('connection-indicator').classList.add('hidden');
            updateStatus('Connected');
        });

        socket.on('disconnect', function() {
            console.log('Disconnected from server');
            document.getElementById('connection-indicator').classList.remove('hidden');
            updateStatus('Disconnected');
        });

        socket.on('connect_error', function(error) {
            console.error('Connection error:', error);
            document.getElementById('connection-indicator').classList.remove('hidden');
            updateStatus('Connection Error - Retrying...');
        });

        socket.on('reconnect_attempt', function(attemptNumber) {
            console.log('Reconnection attempt:', attemptNumber);
            updateStatus('Reconnecting...');
        });

        socket.on('reconnect', function() {
            console.log('Reconnected successfully');
            updateStatus('Reconnected');
            document.getElementById('connection-indicator').classList.add('hidden');
        });

        // Terminal output handlers
        socket.on('terminal_output', function(data) {
            console.log('Received terminal output:', data.line);
            addTerminalLine(data.line);
        });

        socket.on('terminal_history', function(data) {
            console.log('Received terminal history:', data.lines.length, 'lines');
            const terminalOutput = document.getElementById('terminal-output');
            terminalOutput.innerHTML = ''; // Clear "waiting" message
            terminalLineCount = 0;
            
            data.lines.forEach(line => {
                addTerminalLine(line, false); // Don't auto-scroll for history
            });
            
            // Scroll to bottom after loading history
            if (autoScroll) {
                terminalOutput.scrollTop = terminalOutput.scrollHeight;
            }
        });

        socket.on('terminal_cleared', function() {
            console.log('Terminal cleared event received');
            document.getElementById('terminal-output').innerHTML = 
                '<div class="terminal-line">Terminal cleared.</div>';
            terminalLineCount = 1;
        });

        function addTerminalLine(line, shouldScroll = true) {
            console.log('Adding terminal line:', line);
            const terminalOutput = document.getElementById('terminal-output');
            
            if (!terminalOutput) {
                console.error('Terminal output element not found!');
                return;
            }
            
            // Remove "waiting" message if present
            if (terminalLineCount === 0) {
                terminalOutput.innerHTML = '';
            }
            
            // Create line element
            const lineDiv = document.createElement('div');
            lineDiv.className = 'terminal-line';
            
            // Add color coding based on content
            const lowerLine = line.toLowerCase();
            if (lowerLine.includes('error') || lowerLine.includes('failed')) {
                lineDiv.classList.add('error');
            } else if (lowerLine.includes('warning') || lowerLine.includes('warn')) {
                lineDiv.classList.add('warning');
            } else if (lowerLine.includes('info') || lowerLine.includes('loading')) {
                lineDiv.classList.add('info');
            }
            
            lineDiv.textContent = line;
            terminalOutput.appendChild(lineDiv);
            terminalLineCount++;
            
            // Limit number of lines to prevent memory issues
            if (terminalLineCount > MAX_TERMINAL_LINES) {
                terminalOutput.removeChild(terminalOutput.firstChild);
                terminalLineCount--;
            }
            
            // Auto-scroll to bottom if enabled
            if (autoScroll && shouldScroll) {
                terminalOutput.scrollTop = terminalOutput.scrollHeight;
            }
        }

        function toggleAutoScroll() {
            autoScroll = !autoScroll;
            const btn = document.getElementById('toggle-scroll-btn');
            btn.textContent = autoScroll ? 'üîí Auto-scroll: ON' : 'üîì Auto-scroll: OFF';
            btn.style.background = autoScroll ? 'rgba(0, 255, 65, 0.2)' : 'rgba(255, 255, 255, 0.1)';
        }

        function clearTerminal() {
            socket.emit('clear_terminal');
        }

        // Voice Commands functionality
        let voiceCommands = {};

        async function loadVoiceCommands() {
            try {
                const response = await fetch('/api/voice_commands');
                const data = await response.json();
                voiceCommands = data.commands;
                displayVoiceCommands();
            } catch (error) {
                console.error('Error loading voice commands:', error);
                document.getElementById('voice-commands-grid').innerHTML = 
                    '<div style="text-align: center; padding: 20px; color: #ff4444;">Failed to load commands</div>';
            }
        }

        function displayVoiceCommands() {
            const grid = document.getElementById('voice-commands-grid');
            if (Object.keys(voiceCommands).length === 0) {
                grid.innerHTML = '<div style="text-align: center; padding: 20px; color: #888;">No commands available</div>';
                return;
            }

            grid.innerHTML = '';
            for (const [command, description] of Object.entries(voiceCommands)) {
                const btn = document.createElement('button');
                btn.className = 'command-btn';
                btn.innerHTML = `
                    <span class="command-btn-title">${command}</span>
                    <span class="command-btn-desc">${description}</span>
                `;
                btn.onclick = () => executeVoiceCommand(command, description);
                grid.appendChild(btn);
            }
        }

        async function executeVoiceCommand(command, description) {
            console.log('Executing command:', command);
            
            // Find the button that was clicked
            const buttons = document.querySelectorAll('.command-btn');
            let clickedButton = null;
            buttons.forEach(btn => {
                if (btn.querySelector('.command-btn-title').textContent === command) {
                    clickedButton = btn;
                }
            });

            if (clickedButton) {
                clickedButton.classList.add('executing');
            }

            // Add to terminal
            addTerminalLine(`> Executing command: ${command}`, true);
            addTerminalLine(`  Description: ${description}`, true);

            try {
                const response = await fetch('/api/execute_command', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ command: command })
                });

                const data = await response.json();

                if (data.success) {
                    addTerminalLine(`‚úÖ Command executed successfully!`, true);
                    addTerminalLine(`üì§ Result: ${data.result}`, true);
                    console.log('Command result:', data.result);
                } else {
                    addTerminalLine(`‚ùå Command failed: ${data.error}`, true);
                    console.error('Command error:', data.error);
                }
            } catch (error) {
                addTerminalLine(`‚ùå Network error: ${error.message}`, true);
                console.error('Error executing command:', error);
            } finally {
                if (clickedButton) {
                    clickedButton.classList.remove('executing');
                }
            }
        }

        // Page initialization
        document.addEventListener('DOMContentLoaded', function() {
            console.log('Dashboard loaded - terminal output ready');
            const terminalOutput = document.getElementById('terminal-output');
            if (terminalOutput) {
                console.log('Terminal output element found');
            } else {
                console.error('Terminal output element NOT found!');
            }

            // Load voice commands
            loadVoiceCommands();
        });

        // Update camera feed stats
        socket.on('camera_stats', function(data) {
            document.getElementById('fps-display').textContent = `FPS: ${data.fps.toFixed(1)}`;
            document.getElementById('objects-count').textContent = `Objects: ${data.objects}`;
            document.getElementById('avg-fps').textContent = data.fps.toFixed(1);
            document.getElementById('objects-detected').textContent = data.total_objects || 0;
            updateStatus(data.status);
        });



        function updateStatus(status) {
            document.getElementById('status-text').textContent = status;
            const dot = document.querySelector('.status-dot');
            
            if (status === 'Listening...' || status === 'Processing...') {
                dot.style.background = '#ff6b6b';
            } else if (status === 'Answering...') {
                dot.style.background = '#ffd93d';
            } else {
                dot.style.background = '#00ff41';
            }
        }



        // Update session time every second
        setInterval(() => {
            const elapsed = Date.now() - sessionStartTime;
            const minutes = Math.floor(elapsed / 60000);
            const seconds = Math.floor((elapsed % 60000) / 1000);
            document.getElementById('session-time').textContent = 
                `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }, 1000);

        // Camera feed is a continuous stream - no need to refresh manually
        // The /video_feed endpoint uses multipart/x-mixed-replace to stream frames
    </script>
</body>
</html>